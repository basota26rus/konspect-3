# лекция 1
об архитектуре 

Требования к программированию
• Не пытаться сделать максимально просто, использовать знания и паттерны.

• Курс по архитектуре, не все задачи будут на 200 строк кода.

 Выбор языка программирования
• Хаскель может быть хорошим вариантом, но нужно писать по-человечески.

• Рекомендация - использовать камль.

 Архитектура и ее значение
• Архитектура - это то, что делает программу полезной для пользователей.

• Программа в три раза дешевле, чем программный продукт, и в современном мире программы работают в составе программных комплексов.

• Системный программный продукт обладает свойствами программного продукта и программного комплекса.

 Архитектура и размер кода
• Архитектура становится полезной, когда происходит переход от программы к программному комплексу.

• Системы размером более 5000 строк кода требуют архитектуры.

• Системы размером порядка сотен тысяч строк кода требуют архитектуры для удержания в голове классов и взаимосвязей.

• Системы размером порядка единиц или десятков миллионов строк кода требуют архитектуры для предотвращения их разрушения.

 Архитектура программного обеспечения
• В академических кругах под архитектурой системы понимают ее формальные описания, которые позволяют доказывать про нее свойства.

• В продакшене архитектура понимается как свод знаний о том, как система устроена.

• Архитектура эволюционирует, и она появляется с момента появления требований или идеи.

• Архитектура состоит из разных точек зрения на систему, связанных с ее описанием.

• Уровни детализации позволяют найти баланс между детальностью и обозримостью происходящего.

 Преимущества архитектуры
• Хорошая архитектура позволяет сократить затраты на кодирование и упростить жизнь.

• Архитектура - средство для управления проектом, оценки и управления стоимостью.

• Архитектура - хороший способ сэкономить на времени разработки, используя стандартные библиотеки и переиспользуемые компоненты.

• Архитектура - средство анализа системы до написания кода, что позволяет делать утверждения о свойствах системы.

 Архитектор и его обязанности
• Архитектор - это выделенный человек или группа людей, которые отвечают за разработку и описание архитектуры системы.

• Архитектор также отвечает за доведение архитектуры до всех заинтересованных лиц, включая разработчиков, начальство, заказчиков и т.д.

• Архитектор контролирует реализацию, следит за тем, чтобы разработчики делали то, что нужно.

• Архитектор отвечает за поддержание актуального состояния архитектуры, так как разработчики могут отходить от нее.

Стандарты и квалификация архитектора
• Архитектор в российской классификации - это про стандартный шесть на три.

• В стандарте описаны ключевые трудовые функции архитектора, которые раскрываются в трудовых действиях.

• Архитектор занимается анализом требований с точки зрения архитектуры, выбором архитектурного решения, моделированием его, разработкой разделов по архитектуре, проектной документации.

• Архитектор также контролирует реализацию и тестирование, сопровождает эксплуатацию с точки зрения архитектуры.

 Архитектор и его роль в разработке
• Архитектор - это квалифицированный специалист, который должен иметь магистерское образование и уметь решать архитектурные задачи.

• Архитектор должен знать много, но не обязательно глубоко, и уметь доносить архитектуру до всех желающих про нее знать.

• Архитектор должен уметь программировать, но не обязательно быть разработчиком.

• Архитектор должен оставлять пространство для маневра разработчикам и уметь читать диаграммы.

Архитектура и программирование
• Архитектура и программирование - это разные вещи, и архитектор не должен заниматься только архитектурой, но и программированием.

• Первые статьи и книги по архитектуре появились только в 90-х годах, до этого архитектура не существовала как выделенная область знаний.

• Пример разработки программного обеспечения для осцилографа показывает, как архитектура может помочь в разработке сложных систем.

 Проблемы с объектно-ориентированной моделью
• Система организована просто, но не решает задачи, так как пользовательский интерфейс должен управлять параметрами оцифровки.

• Разделение классов на слои не решает проблему, так как классы из разных слоев могут взаимодействовать друг с другом.

 Решение с использованием фильтров и каналов
• Система рассматривается как набор фильтров и каналов, которые соединяют фильтры.

• Фильтры знают только о входных и выходных каналах, не связаны друг с другом.

• Проблема: управление параметрами захвата сигнала и параметрами работы системы.

 Архитектура с каналами управления
• Топологические ограничения на передачу данных, управление фильтрами с помощью передачи управляющих воздействий.

• Возможность управлять системой, анализировать ее как граф.

 Субъективность в архитектуре
• Нет архитектуры лучше или хуже, все зависит от вкуса и интуиции.

• Одна и та же задача может решаться разными архитектурными стилями.

• Ошибка в архитектуре может привести к необходимости рефакторинга всей системы.

 Архитектурные стили и виды
• Архитектурные стили, такие как каналы и фильтры, позволяют создавать архитектуры для разных задач, включая моделирование социографов, сетевых протоколов, операционных систем и других.

• Архитектурные виды, такие как композиция, логическая структура, информационная структура и другие, позволяют описывать систему на разных уровнях детализации.

 Архитектурные виды и визуальные языки
• Архитектурные виды, такие как контекст, композиция, логическая структура, информационная структура и другие, используются для описания системы.

• Визуальные языки, такие как диаграммы, используются для моделирования и управления сложностью системы.

 Архитектура и жизненный цикл системы
• Архитектура начинается с появления требований и используется на всех этапах жизненного цикла системы.

• Архитектура используется для моделирования требований, анализа, проектирования, реализации, тестирования и поддержки системы.

 Требования к архитектуре
• В архитектуре системы важны как функциональные, так и нефункциональные требования, а также бизнес-ограничения и технические ограничения.

• Бизнес-ограничения и технические ограничения играют примерно одинаковую роль, так как они могут быть критичными для архитектуры.

• Если нельзя сделать что-то с помощью определенной технологии, то это может повлиять на архитектуру системы.

 Влияние бизнес-ограничений
• Бизнес-ограничения могут быть критичными для архитектуры, особенно если есть жесткие сроки или большие инвестиции.

• Если есть ограничения по времени или бюджету, то это может повлиять на архитектуру системы.

Функциональные требования и архитектура
• Функциональные требования могут быть реализованы множеством способов, но определяющими для архитектуры являются нефункциональные требования, такие как эффективность, удобство использования, сопровождаемость и безопасность.

• При проектировании архитектуры важно учитывать общие для всей системы вопросы, такие как стратегия обработки ошибок, логирования, обновления и локализации.

 Примеры архитектур
• Пример архитектуры Hadoop, которая состоит из подсистемы вычислений, подсистемы хранения данных и подсистемы хранения данных.

• Исследование архитектуры Hadoop показало, что она отличается от описанной в документации и имеет сложную структуру.

• Несмотря на это, исходные коды Hadoop не соответствуют разбиению на компоненты логическому, и количество связей между компонентами может быть нелогичным.

# 2 лекция
Декомпозиция, объектно-ориентированное проектирование

Сложность в программировании

• Сложность в программировании невозможно полностью исключить, так как само программное обеспечение сложно.
• Управление сложностью - это ключевой принцип программирования.
• Сложность бывает двух типов: существенная и случайная.
• Иерархичность, классификация и абстрагирование помогают управлять сложностью.

Восходящее и нисходящее проектирование

• Восходящее проектирование позволяет тестировать систему на каждом этапе разработки.
• Нисходящее проектирование используется чаще, так как позволяет двигаться к намеченной цели.
• Тестирование возможно и для нисходящего проектирования, но требует дополнительных усилий.

Модульность в программировании

• Модульность - это разделение программы на отдельные компоненты, которые могут быть независимо разработаны и интегрированы.
• Модули должны обладать минимальным внешним интерфейсом, чтобы упростить их использование.
• Каждый модуль должен решать одну задачу и не иметь побочных эффектов.

 Практические приемы и проблемы модульности

• Модульность позволяет создавать сложные системы, разделяя задачу на более простые модули.
• Сложность модульности заключается в определении правильного размера модуля и его границ.
• Стоимость разработки и интеграции модулей увеличивается с ростом их объема и количества.
• Оптимальный размер модуля составляет около 300-400 строк кода.

Метрики модульной архитектуры

• Сопряжение или каплинг - мера взаимозависимости модулей в программе.
• Связанность - степень, в которой задачи модуля связаны друг с другом.
• Автоматически посчитать можно, оценивая количество вызовов функций внутри модуля.
• В объектно-ориентированном программировании есть антипаттерны, например, завистливый метод.

 Объекты и их свойства

• Объекты имеют состояние, поведение и идентичность.
• Идентичность - способ сказать, является ли объект тем же самым или другим.
• Варианты - набор логических условий на состояние объекта, которые должны быть выполнены.
• Варианты могут быть выписаны в виде преды пост условий или логических выражений.
• Варианты повышают надежность программы, даже если они не выписаны и не проверяются.

Объекты и классы

• Объекты отличаются от структур с методами тем, что они не общаются напрямую, а используют поздние связывание и полиморфизм.
• Объекты являются экземплярами класса, но классы не являются обязательным атрибутом объектно-ориентированного программирования.

 Абстракция и инкапсуляция

• Абстракция позволяет выделить существенные характеристики объекта и использовать их для определения действий.
• Инкапсуляция позволяет разделить абстракцию и ее реализацию, предоставив механизм защиты инвариантов абстракции.

 Наследование и композиция

• Наследование - это отношение классификации над типами, где один класс является наследником другого.
• Композиция - это отношение включения объекта одного в другой, где один объект включает другой в качестве своей части.
• Композиция лучше, чем наследование, так как она может меняться на лету и позволяет достигать интересных эффектов.

 Наследование и его применение

• Наследование уместно применять, когда в предметной области есть классификация, например, в биологическом контексте или в компиляторах-грамматиках.
• Наследование также используется для обеспечения полиморфизма и реализации интерфейса.
• В языке программирования C++, наследование может быть концептуально сложным из-за правила "от наследования", которое может нарушать принцип полиморфизма.

 Источники объектов и их использование

• Объекты могут быть получены из предметной области или из способа решения задач.
• Объекты используются для инкапсуляции сложных частей системы, чтобы скрыть сложность и оптимизировать систему.
• Однако, слишком сложная абстракция может быть сложной в использовании и проектировании.
• Идеальная абстракция - это метод, который не принимает параметров и ничего не возвращает, но это не всегда возможно.

 Источники изменений в системах

• Бизнес-правила могут меняться, что требует переписывания системы.
• Часть системы, моделирующая бизнес-правила, должна быть изолирована от остальной системы.
• Примеры: банковские системы, проблемы двухтысячного года.

 Принципы объектно-ориентированного дизайна

• Принципы соли: единственность ответственности, открытость/закрытость, подстановка, замена, инвертирование, информативность.
• Каждый объект должен иметь одну обязанность, не должно быть "швейцарских ножей".
• Модули должны быть самодостаточными и не должны зависеть от других модулей.

 Принцип открытости-закрытости

• Принцип открытости-закрытости говорит, что программы должны быть открыты для расширения, но закрыты для изменения.
• Это означает, что если мы уже опубликовали интерфейс, мы не можем его менять.
• Для расширения программ должны быть определены фиксированные точки расширения, которые позволяют добавлять новое поведение.

 Принцип подстановки Барбары Рисков

• Принцип подстановки Барбары Рисков определяет, что потомок может использоваться везде, где может использоваться предок.
• Это означает, что потомок должен обязательно реализовывать все паблик методы предка и не вносить своих новых вариантов.

 Принцип разделения интерфейсов

• Принцип разделения интерфейсов гласит, что клиенты не должны зависеть от методов, которые они не используют.
• Это позволяет использовать несколько простых интерфейсов вместо одного большого и страшного.

 Принцип инверсии зависимостей

• Принцип инверсии зависимостей говорит, что модули верхних уровней не должны зависеть от модулей нижних уровней.
• Это позволяет использовать общие интерфейсы и избежать прямых зависимостей между классами.

 Использование контейнеров

• Контейнеры, такие как оси, позволяют автоматически собирать объекты по их зависимостям.
• Это может быть полезно для создания сложных систем, где объекты взаимодействуют друг с другом.

 Закон Деметры

• Закон Деметры гласит, что объект не должен лазить в поля и методы чужого объекта, если не иметь к нему напрямую отношение.
• Это правило помогает избежать проблем с изменением реализации объекта и обеспечивает абстракцию.

 Медиатор

• Медиатор - это объект, обеспечивающий взаимодействие между группой объектов.
• Он позволяет обеспечить коммуникацию между объектами, не раскрывая детали реализации каждого из них.

UFС контейнеры

• UFС контейнеры используются для решения проблемы параметрического полиморфизма, когда требуется знать тип объекта.
• Они позволяют обеспечить связь между объектами и решить проблему, не раскрывая детали реализации каждого из них.

 Параметрический полиморфизм

• Параметрический полиморфизм - это способность объекта принимать разные типы данных.
• Генерики позволяют решить проблему параметрического полиморфизма, но не всегда являются лучшим решением.

Единственность ответственности

• Принцип единственности ответственности гласит, что класс должен иметь только одну ответственность.
• Однако, в реальных библиотеках могут быть классы с десятками и сотнями методов, которые все еще могут быть нормальными.

# 3 лекция
Моделирование. UML

 Моделирование в разработке программного обеспечения

• Моделирование используется для уменьшения сложности реальных объектов или явлений, позволяя делать выводы о них.
• Модели могут быть физическими, например, макеты самолетов, или программными, например, диаграммы классов.
• Модели субъективны и могут быть полезны только для определенных целей.

 Примеры моделей

• Диаграмма конечных автоматов используется для моделирования поведения системы, например, торгового автомата.
• Модели могут также отражать контекст системы, например, бизнес-процессы, требования, пользователи и аппаратная платформа.

 Преимущества моделирования

• Моделирование позволяет делать выводы о системе до написания кода, что экономит время и ресурсы.
• Модели могут быть неформальными, например, на доске или фотографии, или полностью исполнимыми, например, на языке программирования.
• Архитектурные модели отражают архитектурные решения системы и могут быть использованы для создания единого архитектурного документа.

 Моделирование архитектуры

• Моделирование - процесс использования формализма для описания архитектуры, уточнения и документирования решений.
• Моделирование активно использует аннотацию, язык или другое средство описания архитектурных решений.
• Хорошая аннотация позволяет направлять процесс моделирования и одновременно с этим направлять процесс создания архитектуры.
• Моделирование не должно быть слишком детальным или формальным, важно учитывать важность описываемого решения.

 Преимущества моделирования

• Моделирование направляет и облегчает процесс проектирования системы.
• Модели - хорошее средство коммуникации между разработчиками.
• Модели - инструмент для общения с заказчиком и документирования.
• Модели могут использоваться как исходники для генерации кода.

Виды моделей

• Модели бывают разных видов, включая естественные языки.
• Естественные языки могут использоваться для первичного анализа предметной области и построения моделей.
• Естественные языки могут использоваться как средство для дополнительного уточнения архитектуры, зафиксированной в коде и других моделях.

 Неформальные графические модели

• Неформальные графические модели менее выразительны, чем естественный язык, но более компактны и быстрее воспринимаются.
• Примеры: архитектурное описание, пауэр-пойнт, эксель.

Формальные графические модели

• Формальные графические модели рисуются на формальных визуальных языках, таких как UML.
• UML имеет 14 видов диаграмм, которые описывают систему с разных точек зрения.
• UML стандартизован и поддерживается многими инструментами.

 Недостатки UML

• UML не имеет строгой семантики, только синтаксис.
• Семантика определена только для двух видов диаграмм: состояний и активностей.
• UML сложно расширять и затачивать под конкретные применения.

 Формальные языки моделирования

• Визуальные языки чаще всего поддерживают кастомизацию, но требуют знания стандарта.
• Текстовые языки, такие как Адель, используются для моделирования встроенных систем и систем реального времени.
• Адель используется для анализа максимальной пропускной способности системы и времени отклика.

 Преимущества и недостатки текстовых языков

• Текстовые языки сложны для использования и требуют изучения.
• Они не так популярны, как визуальные языки, из-за сложности и отсутствия знания о них.

 Метафора визуализации и точка зрения моделирования

• Визуальные модели используют метафоры для изображения абстрактных сущностей.
• Точка зрения моделирования важна для понимания того, для кого рисуется модель и какой аспект системы она моделирует.

 Семантический разрыв и ориентированные языки

• Модели всегда должны быть проще, чем система, чтобы быть полезными.
• Графические исходники не являются моделями, так как содержат много информации, которую сложно анализировать.
• Ориентированные языки работают только для решения конкретных задач в одной предметной области.

 Визуальные языки и их использование

• В робототехнике визуальные языки применяются часто, так как они удобны для обучения детей программированию и работы с картинками.
• Однако, если перейти на другого робота с другими датчиками, программы могут не работать, и язык должен быть изменен.
• Предметно-ориентированные языки заточены под конкретную задачу, но не могут быть использованы для других задач.

 Юмель - популярный визуальный язык

• Юмель - это не один язык, а 14 разных языков, которые выглядят по-разному, но на самом деле являются одним языком.
• Юмель описан на самом языке, что позволяет ему определять себя.
• Юмель формально определен, и вы не можете рисовать что попало, иначе вы перестанете соответствовать стандартам.

 История и развитие Юмель

• Юмель появился в 1996 году, и его первые версии разрабатывались компанией.
• В 1997 году он был стандартизован как международный стандарт.
• В начале 2000-х годов у Юмель появились конкуренты, которые реализовывали стандарт.
• Последняя версия стандарта - Юмель 2.5, выпущенная в 2017 году.
• Юмель изначально создавался для проектирования софта, но позже его пытались использовать для разработки аппаратного обеспечения.

 История визуальных языков

• Обсуждение истории визуальных языков, начиная с сетей Петри в 1930-х годах и заканчивая современными языками, такими как UML.
• Упоминаются различные языки, включая сети Петри, UML, SDL, и другие.

 Диаграммы классов

• Обсуждение синтаксиса диаграмм классов, включая атрибуты и операции.
• Упоминается, что на диаграмме классов могут быть представлены несколько реализаций на разных языках программирования.

 Ограничения и роли

• Обсуждение ограничений и ролей на диаграммах классов, включая использование фигурных скобок для текста или выражений на стандартном языке запросов.
• Упоминается, что стрелка наследования указывает на родителя, а не на потомков, и что кратность пишется со стороны объекта, которого много.

 Атрибуты ассоциации

• В диаграммах классов ассоциации могут иметь атрибуты, которые описывают их свойства.
• Атрибуты ассоциации могут быть публичными, множественными и иметь значения по умолчанию.
• В Юмель версии 2 атрибуты ассоциации и их значения могут быть записаны в виде текста.

 Интерфейсы и стереотипы

• Интерфейсы могут быть нарисованы в виде прямоугольников со стереотипом "интерфейс".
• Стереотипы могут быть определены в документации или в коде.
• В Юмель существуют стандартные стереотипы, такие как "кол" (класс знает о другом классе), "эсциация шаблона" (наличие вычислимого свойства) и "рефйн" (один класс уточняет другой).

 Агрегация и композиция

• Агрегация и композиция уточняют характер владения одним объектом другим.
• Агрегация означает слабую связь, когда объекты не зависят друг от друга, а композиция - более сильную связь, когда один объект владеет другим.
• На диаграммах классов обычно рисуют только ассоциации, а агрегации и композиции используются редко.

 Диаграммы классов

• Диаграммы классов могут рисовать шаблоны и перечисления.
• Шаблоны могут быть нарисованы двумя способами: через угловые скобки или с использованием стереотипа "пайнт".
• Перечисления рисуются так же, как классы, с перечислением элементов.

 Диаграммы пакетов

• Диаграммы пакетов используются для группировки моделей и могут быть вложенными.
• Пакеты могут быть использованы для организации диаграмм на одной диаграмме.

 Диаграммы объектов

• Диаграммы объектов показывают структуру системы во время выполнения и используются совместно с диаграммами классов.
• Объекты рисуются почти так же, как классы, с указанием имени и типа.

 Диаграммы компонентов

• Диаграммы компонентов переживают эволюцию системы и редко требуют изменений.
• Компоненты рисуются как прямоугольники с изображением планки памяти и стереотипом "компонент".

 Диаграммы Гемель

• Диаграммы Гемель используются для изображения системы порядка 250 000 строк кода.
• Рекомендуется использовать этот хелп для изучения синтаксиса диаграмм Гемель.

 Компоненты и порты

• Компоненты имеют порты, которые используются для взаимодействия с внешним миром.
• Интерфейсы компонентов могут указывать зависимость друг от друга.
• Порты часто не рисуются, так как обычно у компонента один интерфейс.

 Интерфейсы и внутренняя структура

• Интерфейсы могут быть нарисованы, если важно показать внутреннюю структуру системы.
• Взаимосвязи между внутренними частями компонента более практичны для рисования.

# 4 лекция
Моделирование и анализ

Использование моделирования при анализе предметной области

• Требования необходимы для понимания, согласования с заказчиком и пользователями, а также для обозначения границ системы.
• Моделирование требований необходимо для планирования проекта и дальнейшего проектирования.

 Диаграмма случаев использования

• Диаграмма случаев использования описывает требования к системе и может использоваться отдельно от методологий проектирования.
• На диаграмме отображаются границы системы, цели использования системы и сценарии использования.

Отношения между случаями использования

• Три вида отношений: включение, расширение и наследование.
• Включение определяет использование одного случая использования в другом, расширение позволяет определить точки расширения.

 Примеры диаграмм случаев использования

• Пример диаграммы случаев использования в аэропорту с наследованием между акторами и случаями использования.
• Экскурсоводу доступна групповая регистрация и чекин багажа, которые расширяются случаями использования, связанными с обработкой багажа.

 Диаграммы случаев использования

• Видео обсуждает диаграммы случаев использования, которые используются для описания взаимодействия между системой и пользователями.
• Диаграммы могут быть сложными и детализированными, но в реальной жизни они обычно упрощаются для удобства использования.
• В случае использования раскрываются в сценарии, который может быть простым или сложным, в зависимости от ситуации.

 Формализм феограмма случаев использования

• Видео обсуждает формализм феограмма случаев использования, который является контекстной диаграммой.
• Этот формализм используется в основном бизнес-аналитиками и редко используется при проектировании программного обеспечения.
• Контекстная диаграмма описывает внешние факторы, влияющие на систему, и может быть полезна для анализа бизнес-процессов.

 Диаграмма характеристик

• Диаграмма характеристик декомпозирует требования, представляя их в виде дерева.
• Обязательные характеристики рисуются закрашенными кружками, опциональные - не закрашенными.
• Диаграмма удобна для автоматической обработки, например, в плагине Clips Modules Project.

 Диаграмма характеристик для роботов

• Диаграмма характеристик используется для конфигурирования роботов, например, в системе ROS.
• Каждый узел робота может быть описан как одна из характеристик на диаграмме.
• Диаграмма полезна для мобильных роботов, которые могут решать разные задачи и иметь разное оборудование.

 Диаграмма требований

• Диаграмма требований представляет собой скелет системы, у которого в голове требования.
• Она используется для быстрого наброска всех возможных требований к системе.
• Диаграмма не является инструментом детального анализа, а скорее инструментом мозгового штурма.

 Диаграмма случаев использования

• Диаграмма случаев использования используется для анализа требований больших систем.
• Она также может быть полезна для анализа требований программных систем.
• Диаграмма случаев использования может быть связана с реализацией системы.

 Диаграмма активности

• Диаграмма активности используется для моделирования бизнес-процессов на ранних этапах работы с системой.
• Она может быть использована для описания алгоритмов и сценариев использования.
• Диаграмма активности работает на основе сетей Петри и имеет семантику, которая может быть описана с помощью сетей Петри.

 Сети Петри

• Сети Петри представляют собой набор мест и переходов, где места могут содержать токи на исполнение.
• Токи могут быть единичными или множественными, и переходы срабатывают, если во всех местах для них есть токи.
• Токи - это не физические сущности, а просто метки текущей исполняемой инструкции.

 Диаграмма активностей

• Диаграмма активностей моделирует параллельные процессы, где токи перекладываются из одного места в другое.
• Токи могут быть отправлены или получены, и когда происходит и то, и другое, процесс завершается.
• Диаграммы активностей могут быть использованы для визуализации ответственности участников бизнес-процесса и асинхронного взаимодействия.

 БМПМ

• БМПМ - это отдельный язык, который появился в 2004 году и развился из идей для анализа бизнес-процессов.
• Он позволяет моделировать взаимодействие между разными участниками бизнес-процесса и координировать их действия.
• Диаграммы активностей на основе БМПМ имеют исполнимую семантику и могут быть использованы для генерации кода на языке бизнес-процессов.

Диаграммы бизнес-процессов

• Видео обсуждает различные типы диаграмм бизнес-процессов, включая диаграммы активностей, хореографии и диалогов.
• Диаграммы активностей позволяют моделировать различные виды синхронных взаимодействий, события и логические условия.
• Диаграммы хореографии показывают, как участники бизнес-процесса взаимодействуют друг с другом, но не детализируют конкретные детали взаимодействия.
• Диаграммы диалогов показывают, кто с кем может взаимодействовать в принципе, но не детализируют конкретные сценарии взаимодействия.

 Диаграммы активностей

• Видео объясняет, как диаграммы активностей могут использоваться для моделирования различных видов синхронных взаимодействий, событий и логических условий.
• Диаграммы активностей также позволяют описывать различные виды событий, включая начальный и конечный блоки, посылку и прием сообщений, обработку ошибок и компенсацию событий ошибок.

 Диаграммы хореографии

• Диаграммы хореографии показывают, как участники бизнес-процесса взаимодействуют друг с другом, но не детализируют конкретные детали взаимодействия.
• Они полезны для понимания общей логики бизнес-процесса, того, с кем и когда участники должны взаимодействовать.

 Диаграммы диалогов

• Диаграммы диалогов показывают, кто с кем может взаимодействовать в принципе, но не детализируют конкретные сценарии взаимодействия.
• Они могут быть полезны для больших бизнес-процессов, где может быть много участников и взаимодействий.

 Использование диаграмм бизнес-процессов

• Видео обсуждает, как диаграммы бизнес-процессов могут быть использованы для понимания контекста, в котором работает система, и для определения частей, которые можно автоматизировать.
• Диаграммы активностей и диалогов могут быть использованы для детализации бизнес-процессов, но они не предназначены для написания кода.

 Диаграмма развертывания

• Диаграмма развертывания описывает, как конкретные артефакты системы размещаются на физическом оборудовании.
• Она помогает понять, какие компоненты нужно разделить систему и какое аппаратное обеспечение потребуется.

 Диаграмма сущность-связь

• Диаграмма сущность-связь моделирует данные и используется для описания модели данных или концептуальной модели предметной области.
• Нотация диаграммы позволяет быстро смоделировать данные в информационных системах и сгенерировать схему базы данных.

 Альтернативные нотации

• Альтернативой диаграммам сущность-связь могут быть диаграммы ORM или моделинг.
• Они отличаются тем, что здесь нет сущностей и атрибутов, а только сущности и анарные связи между ними.
• Диаграммы ORM и моделинг могут быть полезны для анализа предметной области и позволяют быстро смоделировать данные.

# 5 лекция
Моделирование поведения

Диаграммы конечных автоматов

• Обсуждение визуальных языков для моделирования поведения систем, включая диаграммы конечных автоматов.
• Примеры использования конечных автоматов в торговых автоматах, коммуникационных протоколах и других системах.

 Синтаксис диаграмм конечных автоматов

• Описание переходов между состояниями, условий для выполнения переходов, действий при переходах и состояний.
• Примеры использования диаграмм конечных автоматов в реальных проектах.

 Расширенные возможности конечных автоматов

• Вложенные автоматы, параллельные состояния, псевдосостояния и история состояний.
• Реализация конечных автоматов в коде с использованием таблиц состояний.

Таблицы состояний

• В видео обсуждаются таблицы состояний, которые требуют линейного времени на поиск нужного перехода.
• Вместо этого, чаще используются таблицы, где по одному измерению события, а по другому - текущее состояние.
• Это позволяет найти действия для перехода за константное время.

 Генерация и использование таблиц состояний

• Генерация таблиц состояний может быть автоматизирована, например, для лексического анализа с использованием генераторов синтаксических анализаторов.
• В этом случае, грамматика на высокоуровневом языке автоматически генерирует таблицу состояний, которая разбирается с помощью регулярных выражений.

 Паттерн состояния

• Паттерн состояния предполагает создание класса для каждого состояния, реализующего интерфейс с методами для всех возможных событий.
• Если состояние не может перейти по определенному событию, переход остается пустым.
• Контроллер запоминает текущее состояние и переключает его при выполнении действия по переходу.

Недостатки паттерна состояния

• Хотя паттерн состояния удобен для ручной реализации, он может быть неудобен для автоматической генерации из-за большого количества дополнительного кода.
• Также, переходы в автомате разбросаны по классам состояний, что затрудняет понимание работы автомата.

 Диаграммы последовательности

• Диаграммы последовательности используются для визуализации хитрых взаимодействий и отладки.
• Применяются в телекоммуникационных протоколах, но также полезны для проектирования обычных систем.

 Примеры использования диаграмм последовательности

• Визуализация работы системы, тестирование и визуализация влогов.
• Примеры из реальных проектов: инициализация робота, многопоточное исполнение, исполнение скрипта на роботе.

 Синхронные сообщения и удаление объектов

• Синхронные сообщения ожидают ответ и не имеют типичной семантики синхронного исполнения.
• Удаление объектов: внешнее, самоудаление, самоудаление в конце линии активации.

 Диаграммы последовательностей

• Фреймы - механизм для визуализации нетривиальных алгоритмов на диаграммах последовательностей.
• Примеры использования фреймов: цикл, иф, свич кейс.

 Коммуникационные диаграммы

• Визуализация объектов и связей между ними, без линий жизни.
• Примеры: поиск и заказ в магазине книг, взаимодействие сервисов.

 Диаграммы основных структур

• Визуализация системы, запущенной с компонентами и ролями.
• Примеры: телевизор с генератором и презентом, веб-сервер с хостами и логированием.

 Диаграммы коопераций

• Взаимодействие объектов в рамках одного сценария использования.
• Примеры: аукцион, паттерны проектирования.

 Диаграммы кооперации

• Диаграммы кооперации используются для раскрытия порядка взаимодействия между объектами.
• Они не отображают передачу информации между объектами, но показывают, как объекты связаны во время исполнения.

 Временные диаграммы

• Временные диаграммы используются для моделирования систем реального времени.
• Они позволяют визуализировать временные ограничения и взаимосвязи между участниками взаимодействия.

 Диаграммы обзора взаимодействия

• Диаграммы обзора взаимодействия объединяют диаграммы активности и последовательности для визуализации сложных бизнес-процессов.
• Они могут быть полезны для визуализации логической ветвления и циклов в алгоритмах.

 Диаграмма потока данных

• Диаграмма потока данных показывает поток данных в системе, включая процессы, внешние сущности и места временного хранения данных.
• Она может быть полезна в системах, занимающихся обработкой данных.

 Диаграмма компонентов и классов

• Диаграмма компонентов и классов используется для анализа и проектирования архитектуры системы.
• Она раскрывает каждый блок в системе и позволяет визуализировать требования к системе.

 Визуализация диаграмм

• Видео обсуждает использование диаграмм для визуализации процессов и структур в компьютерных системах.
• Упоминается, что стрелки на диаграммах должны быть нумерованы или иметь названия, чтобы их можно было однозначно идентифицировать.
• Обсуждается, что диаграммы могут быть использованы для декомпозиции иерархических структур и определения входов и выходов.

 Диаграммы потоков данных и основные структуры

• Видео объясняет, что диаграммы потоков данных и основные структуры используются архитекторами, но диаграммы ноль могут быть полезны для бизнес-аналитиков.
• Диаграммы ноль представляют собой математический формализм, который может быть использован для анализа программ и бизнес-процессов.

 Петри-сети и их использование

• Видео объясняет, что петри-сети - это тройка из множества мест, множества переходов и функций потока, которые отображают места и переходы на натуральные числа.
• Семантика сетей определяется понятием срабатывания, которое вычисляет маркировку по функции потока.
• Петри-сети могут моделировать не детерминизм, позволяя выбирать случайный переход и его срабатывание или порождать несколько сетей петри, соответствующих сработавшим переходам.

 Сети Петри и их применение

• Сети Петри представляют собой сеть переходов, каждый из которых может срабатывать и перемещать токины между местами.
• Сети Петри могут быть использованы для моделирования конечных автоматов, многопоточных программ, арифметических вычислений, синхронной пересылки сообщений и других задач.

Анализ сетей Петри

• Сети Петри могут быть проанализированы на предмет поведенческих и структурных свойств, таких как достижимость, ограниченность, безопасность, живость, реверсабельность и домашнее состояние.
• Эти свойства могут быть использованы для проверки правильности работы системы и предотвращения переполнения буфера или других проблем.

Анализ сетей Петри

• В видео обсуждаются различные свойства сетей Петри, такие как структурные свойства, структурная ограниченность, структурная живость и другие.
• Для анализа сетей Петри используются два основных подхода: построение линейных уравнений и анализ дерева состояний.

 Примеры использования сетей Петри

• В робототехнике сети Петри используются для обучения роботов и решения задач.
• В статье, на которую ссылается автор, говорится о применении сетей Петри в робототехнике для обучения роботов и решения задач.

# 6 лекция
Структурные шаблоны

 Введение в паттерны проектирования

• Обсуждение важности паттернов проектирования для архитекторов и программистов.
• Упоминание книги "Банда четырех" как основного источника информации.

 Структура документа и его представление

• Обсуждение структуры документа и его внутреннего представления.
• Упоминание различных операций, таких как редактирование, отмена и повторение.
• Обсуждение поддержки различных операций и аналитических функций.

 Компоновщик - паттерн проектирования

• Компоновщик решает задачу представления иерархии объектов и возможности единообразной обработки этой иерархии.
• Компоновщик используется повсеместно, но имеет проблемы с объектно-ориентированным программированием.

 Операции работы с потомками

• Операции работы с потомками могут быть реализованы в компоненте или в листе, но в обоих случаях могут быть проблемы.
• В случае реализации в компоненте, операции могут ничего не делать или бросать исключения.

Списки потомков

• Списки потомков могут быть сложной структурой данных, и их реализация может быть в компоненте или листе.
• В некоторых случаях, ссылки на родителей могут быть полезны для реализации дерева или распространения событий.

 Разделяемые по деревья и разделяемые листья

• Разделяемые по деревья могут экономить память, но усложняют работу с деревом.
• Разделяемые листья могут быть взяты из пула подготовленных листьев для эффективного использования.

 Компоновка и моноглифы

• Компоновка позволяет экономить память и время выполнения, но требует аккуратного обращения с порядком потомков.
• Моноглифы - это базовый класс, который обрамляет сына, добавляя ему новую функциональность.

 Прозрачное обрамление и использование в текстовом редакторе

• Моноглифы позволяют добавлять элементы оформления к фрагментам текста, изменяя их во время выполнения.
• Идея прозрачного обрамления позволяет использовать элементы пользовательского интерфейса внутри физической структуры документа.

 Исторические причины и современные подходы

• Идея прозрачного обрамления возникла в 90-х годах, когда язык программирования Смолток был популярен.
• Современные текстовые редакторы могут использовать пользовательский интерфейс как часть своей внутренней структуры, но это может привести к смешению концепций и странным багам.

 Декоратор и его использование

• Декоратор позволяет добавить функциональность к существующему объекту, не затрагивая его внешний вид.
• Пример использования: добавление информации о типах к абстрактным синтаксическим деревьям.

 Альтернативы декоратору

• Паттерн прокси и адаптер могут выполнять те же функции, что и декоратор, но с некоторыми ограничениями.
• Паттерн стратегия может быть удобнее, но требует модификации декорируемого объекта.

 Разбиение текста на крупные компоненты

• Пользователь может выбирать разные алгоритмы форматирования для разных ситуаций.
• Идея обобщается до паттерна стратегия, где алгоритм форматирования может быть определен в потомках.

 Паттерн стратегия

• Стратегия - это класс, который реализует абстрактный интерфейс и может быть использован в контексте для выполнения определенных действий.
• Стратегия может быть реализована в виде класса или интерфейса, и может быть изменена во время выполнения.

 Применение стратегии

• Стратегия может быть использована для инкапсуляции сложного алгоритма, для переключения между несколькими вариантами алгоритмов, для работы с данными, которые не должны быть известны контексту.

 Реализация стратегии

• Стратегия может принимать данные для работы в качестве параметров или передавать контекст в качестве аргумента.
• Стратегия может быть параметризована с помощью шаблона, что позволяет избежать использования абстрактного класса или виртуальных методов.

Примеры использования стратегии

• В домашнем задании по программированию может быть использована стратегия для определения поведения мобов в игре.
• В Java и C# стратегии могут быть реализованы с помощью интерфейсов или лямбда-функций.

 Адаптеры и прокси

• Адаптеры позволяют использовать сторонние библиотеки в графическом редакторе, реализуя их интерфейс.
• Адаптеры могут быть двух типов: адаптер объекта и адаптер класса.
• Адаптеры класса могут быть полезны для реализации правил наследования.

 Прокси и распределенные приложения

• Прокси могут быть использованы для загрузки изображений из файла только при необходимости.
• Прокси могут быть полезны для распределенных приложений, где запросы отправляются на другую машину и обрабатываются там.
• Прокси также могут использоваться для управления доступом и реализации блокировок.

Прокси и декораторы

• Прокси и декораторы структурно похожи, но прокси обязан реализовывать весь интерфейс проксируемого объекта.
• В случае с прокси, операторы стрелочки вызываются по цепочке до тех пор, пока не будет найден объект без оператора стрелочки.
• Для реализации прокси используется генерация кода, которая позволяет делегировать работу через операторы.

 Фасад

• Фасад - это способ предоставить простой интерфейс к сложной подсистеме, возможно, инкапсулируя ее.
• Фасад может быть абстрактным классом, предоставляющим интерфейс и фабрику для конкретной реализации.
• Фасад гарантирует уровневую архитектуру, так как единственный публичный класс - это фасад, и все взаимодействие происходит через него.

 Паттерн "Приспособленец"

• В текстовом редакторе, где каждый символ является отдельным объектом, может быть сложно хранить миллионы символов.
• Вместо этого, можно использовать паттерн "Приспособленец", который хранит только несколько сотен или тысяч символов в пуле, а каждый композитный объект ссылается на один из них.
• Приспособленцы могут иметь внешнее состояние, которое не разделяется и может быть вычислимо или храниться компактно.

Реализация и применение

• Реализация паттерна "Приспособленец" может быть сложной и требует аккуратной работы с памятью.
• Клиенты не могут создавать приспособленцы самостоятельно, и фабрика должна следить за удалением неиспользуемых приспособленцев.
• В случае с компилятором строковых литералов, где строки интернируются, важно следить за удалением неиспользуемых строк.

Архитектурная документация

• Обсуждение важности архитектурной документации и ее роли в процессе разработки.
• Упоминается, что дизайн-документ может быть неформальным или создаваться по стандартам.
• Упоминается, что наличие хорошего дизайн-документа может сократить затраты на разработку и поддерживать систему.

 Практика создания дизайн-документов

• Упоминается, что дизайн-документы часто встречаются в проектах, где качество имеет большое значение, таких как медицинская и военная сферы.
• Упоминается, что в большинстве компаний дизайн-документы создаются неформально и часто представляют собой набор вики-страниц.

Как писать дизайн-документ

• Дизайн-документ должен быть подробным и содержать информацию для разных стейкхолдеров, включая технических специалистов и менеджеров.
• Упоминается важность использования диаграмм для иллюстрации решений и описания альтернатив.
• Упоминается, что дизайн-документ должен описывать не только само решение, но и все, что вокруг него, включая альтернативы и критерии выбора.

# 7 лекция
7. Порождающие шаблоны

 Паттерн Мост

• Паттерн мост отделяет абстракцию от реализации, что позволяет сделать иерархию классов более гибкой и расширяемой.
• Пример из реальной жизни: система для программирования роботов, где есть абстрактная модель робота и реализация для разных типов роботов.

 Применение паттерна Мост

• Паттерн мост используется, когда у нас есть необходимость вынести реализацию в отдельную иерархию, чтобы избежать смешивания разных реализаций с абстракциями.
• Примеры из книги "Паттерны проектирования": графическая подсистема с абстракцией окна, кнопки и реализацией в виде низкоуровневой графической библиотеки.

Реализация паттерна Мост

• Реализация может быть инкапсулирована в абстракции или приниматься извне, например, как параметр конструктора или значение в конфигурации.
• Фабричный метод позволяет создавать реализации без зависимости от конкретной операционной системы.

 Паттерн "Мост"

• Паттерн "Мост" - это идема программирования, которая может быть рассмотрена как вырожденный мост, когда абстракция имеет только одну реализацию.
• В примере с паттерном "Мост" класс имеет только одно поле и один метод, которые ссылаются на его правила части.
• Это позволяет избежать необходимости подключения заголовочных файлов для клиентов, которые используют только паблик-интерфейс класса.

 Преимущества использования паттерна "Мост"

• Использование паттерна "Мост" позволяет увеличить скорость сборки системы, так как только один заголовочный файл компилируется.
• Этот подход особенно популярен при реализации библиотек, так как он позволяет не ломать компиляцию и бинарную совместимость при изменении реализации.

 Использование паттерна "Мост" в библиотеках

• В библиотеках каждый библиотечный класс реализует паттерн "Мост", используя одно поле по импул, которое ссылается на его правила части.
• Это позволяет клиентам подключать только заголовочные файлы, необходимые для паблик-интерфейса, и избежать необходимости перекомпиляции при изменении реализации.

 Фабричный метод

• В компьютерной игре можно создавать разных юнитов с разной логикой и параметрами.
• Фабричный метод позволяет создавать объекты без необходимости выбирать конкретный класс.
• Пример на плюсах: виртуальный конструктор, который симулируется с помощью имплемента.

 Статический метод

• Статический метод может играть роль конструктора, но требует хард-кода логики создания и реализации всех методов.
• Фабричный метод предлагает сделать конструктор виртуальным с возможностью переопределения в конкретных типах.

 Текстовый редактор

• Фабричный метод используется в текстовом редакторе для создания новых документов.
• Пример: создание нового текстового документа с помощью фабричного метода.
• В реальной жизни фабричный метод часто реализуется с помощью лямда-функций.

 Фабричный метод

• Фабричный метод позволяет создавать объекты, используя абстрактный класс, который определяет интерфейс для создания объектов.
• Фабричный метод может быть параметризован, что позволяет создавать объекты разных типов.
• Фабричный метод может быть использован для создания иерархии классов, где каждый класс реализует свой вариант создания объекта.

 Абстрактная фабрика

• Абстрактная фабрика позволяет создавать объекты разных типов, используя один класс, который определяет интерфейс для создания объектов.
• Абстрактная фабрика может быть использована для создания иерархии классов, где каждый класс реализует свой вариант создания объекта.
• Абстрактная фабрика может быть полезна для создания иерархии классов, где каждый класс реализует свой вариант создания объекта.

 Фабрика и паттерн одиночка

• Фабрика может быть одиночкой, но если она параметризуется разными объектами, то лучше не делать ее одиночкой.
• Фабрика может инициализироваться прототипами или клонированием каждого прототипа.
• В Java или C# можно использовать метатип класс для передачи объекта типа класс фабрике.

 Многопоточность и паттерн одиночка

• Паттерн одиночка используется для гарантии существования только одного экземпляра в системе.
• Статический метод инстанс гарантирует единичность экземпляра.
• Синглтон может быть реализован с использованием ленивого создания объекта.
• Многопоточность может вызвать проблемы с реализацией синглтона.
• Для решения проблем с многопоточностью используется двойной чек-лок.

 Мультитон

• Мультитон - модификация синглтона, которая предполагает наличие нескольких одиночек, идентифицируемых по ключу.
• Мультитон сложнее реализовать многопоточно.

 Проблемы с одиночками

• Одиночки могут вызывать проблемы с многопоточностью и аккуратным модульным тестированием.
• Одиночки нарушают единственность ответственности, так как они поддерживают свой жизненный цикл и реализуют бизнес-логику.

Ленивая инициализация

• Ленивая инициализация позволяет избежать вычисления значения выражения до тех пор, пока оно не понадобится.
• Примеры использования ленивой инициализации: джаст-тайм компиляция, ленивые структуры данных, последовательности в хаскеле и шарпе.
• Ленивая инициализация может быть полезна для поддержания иллюзии бесконечности и поддержки многопоточности.

 Паттерн "пул объектов"

• Пул объектов - это паттерн, который позволяет управлять временем жизни объектов, создавая и уничтожая их по мере необходимости.
• Классический пример - пул потоков.
• В DotNet есть класс Thread, который представляет собой абстракцию потока.
• Создание и остановка потока - это долгая операция, требующая создания дискриптора потока в пространстве ядра операционной системы.
• В общем, создание и остановка потоков - это сложная и ресурсоемкая операция, поэтому обычно не создают поток под каждую конкретную задачу.

Проблемы с многопоточностью

• Тредпул в DotNet - это одиночка, который создает заранее определенное количество потоков, которые крутятся в бесконечном цикле, ожидая задачи из очереди.
• Если задач мало и число потоков больше, чем нужно, то потоки удаляются.
• Проблемы с многопоточностью могут возникнуть, если задачи блокируют потоки из пула, например, выполнение синхронных операций.
• В языках со сборкой мусора, таких как Java и C#, выделение памяти происходит быстро, но могут возникнуть проблемы с сборщиком мусора, если происходит постоянное выделение и освобождение памяти.
• Пул объектов может помочь в таких ситуациях, но требует аккуратного использования памяти и внимания к локациям.

Прототип и его реализация

• В видео обсуждается прототип как способ решения проблем с большим количеством классов во фабричных методах и фабриках.
• Пример: редактор нот, где есть разные типы элементов (ноты, полуноты, скрипичный ключ и т.д.) и клиентская часть, которая работает с этими элементами.
• Идея: создать метод клонирования для каждого элемента в палитре, чтобы можно было просто вытащить элемент на сцену и разместить его там.
• Прототип обобщается до паттерна, где клиент может клонировать объекты, не зная их конкретный тип.

Реализация клонирования

• Клонирование объекта может быть проблематичным, поэтому обычно реализуется вручную с помощью рефлексии или вручную.
• Прототипы хорошо работают с пулом объектов в виде реестра прототипов.
• При клонировании целого набора объектов возникает вопрос о выборе между глубоким и мелким копированием.
• Глубокое копирование - это когда у нас получается такое же дерево в качестве копии, мелкое копирование - это когда у нас получается структура данных с копированным узлом и ссылками на исходные узлы.
• Мелкое копирование работает быстрее, но глубокое копирование - это то, что ожидает пользователь.
• При инициализации клонирования параметры практически никогда не передаются, так как каждый конкретный клонируемый объект может иметь свои параметры.

# 8 лекция
 Поведенческие шаблоны

 Паттерн Строитель

• Паттерн Строитель используется для создания объектов поэтапно, с возможностью реагировать на этапы по-разному.
• Пример: конвертация текстового документа в разные форматы.
• Общая схема паттерна: директор, билдер, квант, продукт.
• Конкретные билдеры могут быть реализованы без абстрактного класса, если нужно создавать несколько разных видов продуктов.

 Примеры из реальной жизни

• Стрим-билдер: используется для конкатенации строк, работает за линейное время.
• Паттерн билдер в библиотеке гуава: используется для создания графов с разными представлениями.
• Паттерн наблюдатель: используется для скоординированного изменения представления объекта.
• Пример: числовые данные представляются в виде таблицы, строковой, столбчатой диаграммы или диаграммы секторами.

 Паттерн наблюдатель

• Паттерн наблюдатель используется для реализации событийно-ориентированной схемы в программировании.
• В Java паттерн реализуется через анонимные классы и механизм с вложенным классом, который имеет ссылку на объект объемлющего класса.
• В C# паттерн реализуется через ключевое слово "событие", которое позволяет подписываться и отписываться от событий.
• В C++ паттерн может быть реализован с помощью лямбда-функций.

 Проблемы с паттерном наблюдатель

• Паттерн может привести к утечке памяти в языках с сборщиком мусора.
• Утечки памяти могут быть обнаружены только при тщательном тестировании.
• Проблемы с последовательностью событий при отправке и нотификации могут привести к некорректной работе системы.
• Для предотвращения таких проблем необходимо быть аккуратным в управлении отправкой идентификаций и переопределении методов.
• Документирование того, кто какие идентификации бросает, может помочь в отладке и сэкономить время.

 Паттерн "Наблюдатель"

• В этом паттерне, наблюдатель запрашивает у сабжекта информацию о произошедших изменениях.
• Существуют две концептуальные схемы: пул и пуш.
• Пул-схема: обсервер запрашивает у сабжекта информацию о произошедших изменениях, а затем обновляет себя.
• Пуш-схема: сабжек сразу передает всю необходимую информацию обсерверам, которые обновляют себя.
• Комбинированная схема: сабжек сообщает об изменениях, а затем спрашивает обсерверы о том, что именно изменилось.

 Паттерн "Шаблонный метод"

• В этом паттерне, общая операция выражается в терминах базовых операций, которые являются точками расширения для шаблонных методов.
• Это позволяет избежать ошибок, связанных с последовательностью действий.
• Шаблонные методы могут быть виртуальными или не виртуальными, но лучше делать их не виртуальными для избежания путаницы.
• Примитивные операции могут быть виртуальными с поведением по умолчанию или чисто виртуальными.
• Соглашение об именовании может помочь отличить примитивные операции от шаблонных методов.

 Паттерн-посредник

• Паттерн-посредник используется для борьбы с большим количеством связей между объектами.
• Пример: панелька с выбором шрифтов и зависимости между элементами управления.
• Решение: создание одного объекта, отвечающего за коммуникацию всех остальных объектов (медиатор).
• Медиатор может быть реализован с помощью паттерна наблюдатель.

 Паттерн-команда

• Идея паттерна: отделение инициации запроса от исполнения запроса.
• Пример: сохранение документа через разные элементы управления (кнопки, меню, ходкей).
• Решение: создание объекта, представляющего действие, которое можно отложить, исполнить, отменить.
• Пример использования: реализация сложных действий в текстовом редакторе.

 Паттерн "Команда"

• Клиент создает команду, которая содержит бизнес-логику и может быть исполнена.
• Команда может быть реализована в виде лямбда-функции или класса.
• Команды могут быть параметризованы, но обычно это не делается.
• Команды могут быть использованы для реализации андуриду и отмены действий.

 Реализация команд

• Команды могут быть реализованы по-разному, от очень глупых до умных.
• Команды могут содержать бизнес-логику и могут быть использованы для реализации пользовательского интерфейса.
• Команды могут быть реализованы с помощью контроллеров, которые принимают команды и складируют их для последующей отмены.

 Примеры использования команд

• Команды могут быть использованы для реализации сложных действий, таких как редактирование документов.
• Композитные команды могут быть использованы для реализации последовательного применения элементарных команд.
• Хранители могут быть использованы для сохранения состояния системы и восстановления его при необходимости.

 Паттерн "Команда"

• В контексте программирования на Куай, возникает потребность в реализации паттерна "Команда" для взаимодействия компонентов внутренней системы.
• Для этого используется класс "Ку-Экшн", но он не подходит для синхронного взаимодействия компонентов.
• Поэтому был создан свой аналог, который позволяет реализовать паттерн "Команда".

 Паттерн "Цепочка ответственности"

• Паттерн "Цепочка ответственности" позволяет создавать цепочки из объектов, которые могут обрабатывать события.
• Если один из элементов цепочки не может обработать событие, он передает его дальше по цепочке.
• Пример использования: распространение событий внутри оконных интерфейсов.

 Реализация паттерна "Цепочка ответственности"

• На диаграмме классов представлен абстрактный класс "Хелп-Хендлер", который имеет ссылку на следующий объект цепочки.
• Конкретные классы, такие как "Батон", могут реализовывать этот класс и обрабатывать события.
• Если хелп для конкретного элемента не задан, вызывается "Хэнд-Хелп", который отправляет запрос дальше по цепочке.

 Проблемы и решения

• Проблема: при добавлении нового вида запроса, нужно модифицировать все обработчики.
• Решение: использовать объекты "Запрос", которые могут иметь наследников.
• Это позволяет добавлять новые виды запросов без изменения существующих обработчиков.
• Пример: обработчики событий в .NET, где используется класс "Авентаркс", который является абсолютно пустым, но все обработчики событий должны принимать его наследников.

 Паттерн "Состояние"

• Паттерн "Состояние" позволяет динамически менять поведение объекта на лету, так что извне кажется, что объект поменял свой тип.
• В языках со строгой типизацией это невозможно, но в JavaScript можно подменить тип объекта прямо в процессе выполнения.
• Паттерн "Состояние" позволяет модифицировать поведение объекта на основе его текущего состояния.
• Пример: сетевое подключение, где состояние может быть открыто или закрыто, и поведение объекта зависит от этого состояния.

 Паттерн "Посетитель"

• Паттерн "Посетитель" используется для выполнения разных операций над синтаксическим деревом.
• Пример: проверка типов, печать дерева в красивом формате и генерация машинного кода.
• Недостатки стандартного решения с использованием абстрактного класса и виртуальных методов: необходимость модификации всей структуры при добавлении новой операции.
• Нормальное решение - вынести операции над структурой данных в отдельный класс.

 Паттерн "Визитор"

• В паттерне "Визитор" используется абстрактный базовый класс, который объявляет метод "акцепт", принимающий объект "нодвизитор".
• В каждом из наследуемых классов "акцепт" реализуется в одну строчку, вызывая метод "визит", соответствующий конкретному классу.
• "Визитор" реализует интерфейс, но в каждом конкретном случае реализует один метод, соответствующий каждому узлу дерева.
• Преимущество такого подхода заключается в том, что дерево ничего не знает о аналитических операциях, которые в нем можно реализовать.
• Вся логика реализуется в "визиторах", которые инкапсулированы в них.

 Двойная диспетчеризация

• "Визитор" - это рукописная реализация двойной диспетчеризации, которая позволяет вызывать действия в зависимости от двух разных факторов: элемента и "визитора".
• В фронтами это выглядит так: объектная структура дергает "визитор", который, в свою очередь, дергает конкретный элемент.
• Элемент, в свою очередь, дергает "визитор", который вызывает операцию к конкретному элементу.

 Применение паттерна "Визитор"

• "Визитор" может управлять обходом, который может быть реализован как коллекция, которая ходит по себе и дергает "визитор" для каждого элемента.
• "Визитор" также может иметь свое состояние и накапливать его постепенно, что может быть использовано для преобразования деревьев.
• "Визитор" может использовать перегрузку методов, но это не рекомендуется, так как визуально сложно понять, какой именно "визитор" вызывается.

# 9 лекция
 Антипаттерны

 Антипаттерны и их причины

• Антипаттерны - это именованные наборы стандартных решений, которые могут привести к плохим свойствам системы.
• Они могут быть полезны для изучения общего словаря знаний и решения проблем.

 Экономические причины антипаттернов

• Спешка и апатия могут быть причинами появления антипаттернов.
• Нежелание делать хорошо может привести к использованию плохих решений.

Смертные грехи программирования

• Нежелание погуглить перед тем, как что-то делать.
• Ленивость и жадность могут привести к принятию непродуманных решений.
• Архитектурная жадность может привести к трагедии архитектурного паралича.
• Неведение может привести к непониманию существующих решений и их исправлению.
• Гордость может привести к нежеланию использовать готовые решения.

Проблемы с архитектурой и паттернами

• Обсуждение важности управления архитектурой и качеством кода, а также избегания попыток реализовать все самостоятельно.
• Упоминание о том, что попытка реализовать что-то свое может привести к большим трудозатратам.

 Круговые зависимости и последовательная связанность

• Обсуждение проблемы круговых зависимостей, когда несколько компонентов зависят друг от друга.
• Упоминание о том, что в некоторых языках, таких как C++, круговые зависимости могут быть запрещены на этапе компиляции.
• Обсуждение проблемы последовательной связанности, когда необходимо вызывать методы в определенном порядке.
• Упоминание о том, что это может быть сложно избежать, особенно в процессе инициализации сложного приложения.

 Борьба с проблемами архитектуры

• Обсуждение различных способов борьбы с проблемами архитектуры, включая использование семантики языка, порождающие паттерны, такие как шаблонный метод и фабрика, а также использование паттерна Builder.
• Упоминание о том, что эти методы могут быть сложными и трудоемкими, но они могут помочь в борьбе с проблемами архитектуры.

 Антипаттерны в программировании

• Параметризация создания объектов и использование контейнеров для скрытия сложной логики.
• Антипаттерны: мост, проблема с вызовом метода предка, проблема с крутящимися ожиданиями, проблема с яра hiding.

 Примеры антипаттернов

• Проблема с вызовом метода предка.
• Проблема с крутящимися ожиданиями.
• Проблема с яра hiding.

 Решение антипаттернов

• Использование паттерна мост для разделения иерархии наследования.
• Использование планировщика и аппаратных прерываний для решения проблемы с крутящимися ожиданиями.
• Избегать использования антипаттернов в реальных проектах.

Ошибки и их исправление

• В видео обсуждается важность исправления ошибок в коде, особенно в операционных системах.
• Упоминается, что исправление ошибок может занять много времени и ресурсов, но это необходимо для обеспечения стабильной работы системы.
• Обсуждаются различные подходы к исправлению ошибок, включая использование скриптов и перезапуск системы.
• Упоминается важность логирования ошибок и состояния системы, а также необходимость избегать проглатывания сообщений об ошибках.

Магические числа и строки

• В видео обсуждаются магические числа и строки в коде, которые могут вызвать проблемы при переводе программы на другой язык.
• Упоминается, что использование именованных констант для чисел и локализация строк могут помочь избежать этих проблем.

 Архитектура и разделение ответственности

• В видео обсуждаются проблемы, связанные с использованием одного класса для управления всем процессом вычислений в системе.
• Упоминается, что это может привести к неконтролируемому коду и проблемам с сопровождением.
• Обсуждаются различные подходы к разделению ответственности и рефакторингу кода, включая использование "швейцарского ножа" и "наследства".

Антипаттерны в программировании

• Медиатор - антипаттерн, который может стать проблемой из-за его способности координировать непрямые зависимости.
• Швейцарский нож - антипаттерн, который пытается быть более гибким, чем нужно, и может нарушить принципы ответственности и абстракции.
• Гудок жетон - антипаттерн, который пытается быть более специфичным, чем нужно, и может быть сложным в использовании.

Потоки лавы и их последствия

• Потоки лавы - антипаттерн, который возникает, когда разработчики активно пробуют разные варианты, но в итоге выбирают одно решение и не исправляют другие.
• Это может привести к появлению временных решений, которые застывают в системе и могут существовать годами.

Борьба с антипаттернами

• Использование прототипирования и проектирования для предупреждения антипаттернов.
• Использование контроля версий с метками для борьбы с временными решениями.
• Архитектурный рефакторинг - сложный, но эффективный способ борьбы с антипаттернами.
• Функциональная декомпозиция - антипаттерн, который может быть преодолен путем поиска и использования лучших технологий для решения задачи.

# 10 лекция 
 Архитектурные стили

 Архитектурные стили и шаблоны

• Архитектурные стили - это именованные наборы решений, которые обладают известными свойствами и применяются к системе или крупному куску системы.
• Архитектурные шаблоны - это тактические идеи архитектуры части системы, которые могут описывать архитектуру взаимодействия с пользователем.

 Примеры архитектурных стилей и шаблонов

• Трехзвенная архитектура: клиент, бизнес-логика, база данных.
• Модул-контроллер: разделение между вью, контроллером и моделью для обработки пользовательского ввода и хранения данных.
• Модуль-вью: вью отображает информацию пользователю, контроллер обрабатывает пользовательский ввод и модель хранит данные и бизнес-логику.
• Модуль-контроллер: используется в разработке веб-приложений, где вью и контроллер взаимодействуют через модель.
• Модуль-вью-моду: используется в разработке графических клиентов и мобильных приложений, где вью и модель взаимодействуют через вью-моду.

Архитектурные шаблоны

• В робототехнике и других приложениях, которые собирают данные и выдают результат их обработки, используется архитектурный шаблон, который описывает жизненный цикл приложения.
• Внутри этого шаблона может скрываться сложная логика, которая может быть реализована с помощью других шаблонов или архитектурных стилей.

Архитектурные стили

• Архитектурные стили в программировании, как и в архитектуре зданий, выбираются на основе предпочтений, а не насущной необходимости.
• Архитектурные стили могут быть привязаны к конкретному окружению, в котором работает система.
• Архитектурные стили могут использоваться для разных подсистем, которые могут быть реализованы в разных стилях.

Зачем нужны стили

• Стили позволяют переиспользовать опыт старших товарищей, избавляют от архитектурного паралича и позволяют быстрее прийти к работоспособному решению.
• Архитектурные стили предполагают использование кода и фреймворков, которые реализуют определенный стиль.
• Архитектурные стили могут предоставлять методы анализа и визуализации, которые могут быть специфичными для данного стиля.

Архитектурные стили

• В видео обсуждаются ключевые характеристики архитектурных стилей, включая набор используемых элементов, правила конфигурирования и семантику.
• Рассматриваются различные стили, включая сырой объектно-ориентированный стиль, слоистый стиль и другие.

Преимущества слоистых стилей

• Слоистые стили предлагают упорядоченное взаимодействие системы, облегчая проектирование и сопровождение.
• В качестве соединителей могут использоваться протоколы взаимодействия слоев, что позволяет заменять или не реализовывать слои.
• Слоистые стили также позволяют постепенно строить систему, начиная с низкого уровня абстракции и постепенно увеличивая его.

Слоистый стиль

• В слоистом стиле каждый уровень знает только о следующем уровне ниже.
• Строгий стиль гарантирует, что изменения в реализации одного уровня затрагивают только непосредственно зависимый уровень.
• Проблемы: необходимость прокидывать сообщения между уровнями, проблемы с производительностью, проблемы с предметной областью.

 Четырехуровневый стиль

• Пользовательский интерфейс, уровень приложения, доменный уровень, инфраструктурный уровень.
• Взаимодействие только сверху вниз, поток управления может двигаться и снизу вверх.

 Клиент-серверная архитектура

• Сервер хранит информацию о сессии с каждым клиентом, может открывать долгосрочное соединение.
• Клиенты имеют право взаимодействовать только с сервером, не знают друг о друге.
• Сервер не имеет права знать о клиентах.
• Мультиплеерные и графические приложения могут быть устроены по клиент-серверной схеме.

 Гексагональная архитектура

• В гексагональной архитектуре, в отличие от классических подходов, уровень предметной области находится на самом нижнем уровне.
• Система собирается из компонентов, каждый из которых состоит из модели предметной области и классов, реализующих ее, а также портов и адаптеров, позволяющих этой предметной области взаимодействовать с внешним миром.
• Название "гексагональная архитектура" связано с тем, что ее удобно рисовать шестиугольниками, и она состоит из компонентов, каждый из которых состоит из модели предметной области и классов, реализующих ее.

Адаптеры и порты

• Адаптеры конвертируют запросы извне в внутреннее представление, удобное для работы доменной модели, и отвечают за валидацию и верификацию данных.
• Модель предметной области может использовать данные, хранящиеся в базе данных, с помощью адаптера базы данных.
• Адаптеры могут быть разными, и система может использовать разные реализации баз данных, такие как PostgreSQL или SQLite.

Изоляция механизмов доставки и вспомогательных механизмов

• Гексагональная архитектура позволяет полностью изолировать механизмы доставки и вспомогательные механизмы, что делает ее популярной.
• Однако, есть тонкость в том, что делать с фреймворками, такими как .NET или Java, которые могут быть вспомогательными механизмами.
• В реальных проектах, бизнес- логика часто является отдельным приложением, которое имеет минимум внешней зависимости.

 Гексагональная архитектура

• Гексагональная архитектура обеспечивает удобство тестирования, так как определены интерфейсы и адаптеры, что позволяет тестировать систему независимо и без проблем.
• Бизнес-логика максимально проста, что важно при работе с сложной предметной областью.
• Однако, гексагональная архитектура может быть тяжеловесной, так как приходится создавать отдельные проекты для каждого возможного пути доставки.

 Луковая архитектура

• Луковая архитектура уточняет уровень бизнес-логики в гексагональной архитектуре, разделяя систему на слои со строгим топологическим ограничением.
• В центре системы находится модель предметной области, над которой находятся доменные сервисы, апплики и инфраструктурные объекты.
• Луковая архитектура предполагает не строгую уровневость, позволяя внешнему миру взаимодействовать с доменной моделью.

 Гексагональная архитектура

• В видео обсуждается гексагональная архитектура, которая является развитием модели предметной области на слои.
• В этой архитектуре есть сущности предметной области, юс-кейсы, сервисы, контроллеры, презенты и гайтвей.
• Все эти элементы взаимодействуют друг с другом, используя порты и адаптеры.

 Чистая архитектура

• В чистой архитектуре поток управления более детализирован и явный.
• В ней есть границы системы, внешний мир и машинное обеспечение для взаимодействия с внешним миром.
• Внутри системы только корректная информация, прошедшая верификацию, валидацию и конвертацию.

 Пакетная обработка

• В пакетной обработке данные обрабатываются в рамках одного дня, сортируются по номеру аккаунта и вычисляется новый баланс.
• Каждая программа является отдельной программой и взаимодействует с другими программами через стандартные способы операционной системы, такие как пайпы.
• Этот стиль широко используется в мире Linux, где программы могут быть написаны на разных языках программирования.

 Каналы и фильтры

• В архитектуре каналов и фильтров, вся система строится из фильтров, связанных каналами, которые преобразуют данные.
• Фильтры не имеют права знать друг о друге, но могут декларировать порты для втыкания каналов.
• Фильтры могут быть по-разному собраны друг с другом и легко заменены.
• Преимущество такого подхода - хорошая озируемость, широкие возможности для анализа и параллелизма.
• Однако, последовательное исполнение и сложность обеспечения интерактивности могут быть проблемами.

 Блэкборд и агенты

• В архитектуре с блэкбордом и агентами, данные движутся ограниченно через центральную структуру данных - блэкборд.
• Агенты взаимодействуют только с блэкбордом, берут информацию и заменяют ее на результат обработки.
• Агенты не имеют своего состояния, все необходимое для работы хранится на блэкборде.
• Блэкборд является узким местом в системе, но позволяет решать задачи, которые не имеют адекватного алгоритмического решения.
• Блэкборд активно применяется в трансляторах и графовых грамматиках.

 Алгоритмы Маркова

• Алгоритмы Маркова - это попытка формализации процесса вычисления, которая конкурирует с машинами Тьюринга и лямбда-исчислением.
• Алгоритмы Маркова устроены как грамматики, где есть набор продукций над строками, которые применяются к входной строке.
• Это позволяет записывать произвольные вычисления.

 Архитектурные стили

• Архитектурные стили, такие как каналы и фильтры, имеют общую структуру данных и последовательное применение продукций.
• В сборном стиле, напротив, агенты применяются до тех пор, пока могут, и порядок их применения не определен.

 Событийные стили

• Событийные стили стремятся отвязать отправителя от сообщения и получателя, используя события вместо методов.
• Это позволяет легко переиспользовать компоненты и конфигурировать систему во время выполнения.

 Преимущества и недостатки событийных стилей

• Преимущества: низкая связность между компонентами, возможность переиспользовать компоненты, конфигурируемость.
• Недостатки: сложность понимания порядка доставки событий, сложность отладки, зависимость от порядка доставки.
• Уточнения: паблиш и пуш-модели для организации передачи информации между издателями и подписчиками.

 Событийная шина

• В событийной шине компоненты могут выступать как издатели, подписчики или издатели и подписчики одновременно.
• Шина передает сообщения между компонентами, которые могут быть умными или тупыми.
• В большинстве случаев шины тупые, они просто доставляют сообщения всем подписчикам.

 Сорсинг и согласованное состояние

• Сорсинг позволяет компонентам не иметь собственного состояния, а строить его на основе сообщений.
• Это позволяет избежать синхронизации и поддержания общего распределенного состояния.

 Пир-пир системы

• Пир-пир системы построены на принципе децентрализованного решения задач.
• Каждый узел сети может хранить файлы и раздавать их другим узлам, что позволяет распределять сетевую нагрузку.
• Пир-пир системы устойчивы к ошибкам и помехам, могут быть масштабируемыми и легко добавлять и убирать узлы.

# 11 лекция
 Предметно-ориентированное проектирование

 Предметно-ориентированное проектирование

• Предметно-ориентированное проектирование (DDD) - методология, которая отвечает на вопрос "как создавать архитектуру системы".
• DDD не предполагает написание архитектуры конкретного приложения, а анализирует предметную область, строит ее модель и выражает ее в коде.
• Цель DDD - создать приложение, которое существенно лучше, чем ожидается, а не просто хорошее приложение.

 Пример использования DDD

• Пример использования DDD - задача о печатных платах.
• DDD помогает разобраться в предметной области, понять, что на самом деле нужно заказчику.
• DDD позволяет избежать двусмысленностей и тестировать модель, общаясь друг с другом на едином языке.

Важность единого языка

• Единый язык определяется моделью предметной области и используется всеми разработчиками.
• Единый язык позволяет избегать двусмысленностей и тестировать модель.
• DDD предполагает использование кода, естественного языка и диаграмм для моделирования.

 Создание модели предметной области

• Эванс и эксперт обсуждают задачу программной прозвонки печатной платы.
• Эванс предлагает добавить параметр к сигналу, который будет увеличиваться на один каждый раз, когда сигнал проходит через сеть.
• Вводится сущность "компонент тайп", которая связана с таблицей пушей.

 Эволюция модели

• Эванс создает консольное приложение, которое получает информацию о топологии печатной платы и выдает информацию о программной прозвонке.
• Модель эволюционирует до удовлетворительного приложения, которое покрывает все требования и удобно в использовании.

 Использование диаграмм классов и объектов

• В модели могут появляться сущности, которых нет в предметной области, например, тип компонента.
• Диаграммы классов и объектов используются для анализа и классификации.
• Диаграммы объектов полезны для обсуждения с экспертом и наведения классификации.

 Единый язык общения

• В проекте может быть несколько команд разработчиков, и для каждой из них вводится единый язык общения, включающий понятия из модели предметной области.
• Это позволяет избежать размывания смысла и непонимания между командами.

 Моделирование и естественный язык

• Моделирование с использованием естественного языка позволяет переиспользовать многотысячелетний опыт общения и объяснения предметной области.
• Моделирование помогает объяснить архитектуру проекта и предметную область.

 Моделирование и код

• После обсуждения модели с экспертами, ее необходимо отразить в коде в виде набора классов.
• Модель должна быть достаточно подробной, чтобы ее можно было реализовать, и достаточно простой для понимания экспертами.
• Процесс рефакторинга модели и кода может проходить много раз, чтобы найти золотую середину между простотой и подробностью.

 Разрушительный рефакторинг

• Разрушительный рефакторинг - это попытка улучшить код, которая приводит к ухудшению качества системы.
• Пример: попытка ускорить работу кода приводит к потере сопровождаемости.

Выбор парадигмы и языка реализации

• Выбор парадигмы и языка реализации должен быть основан на понимании предметной области.
• Пример: если модель предметной области построена в виде взаимодействующих классов, то язык реализации должен быть объектно-ориентированным.

Понимание предметной области

• Дизайнер приложения должен погрузиться в предметную область, чтобы выразить ее в коде.
• Программисты не любят такое, но примерное ретивное проектирование утверждает, что это необходимо для создания качественных продуктов.

 Специализация в предметной области

• Начиная с определенного уровня карьеры, программисты должны выбрать специализацию в рамках предметной области.
• Например, если вы знаете нейрохирургию, вы можете быть ценным специалистом для компаний, разрабатывающих софт для нейрохирургии.

Четырехуровневая архитектура

• Предметная область - это ценность, которая делает приложение полезным для конечного пользователя.
• Предлагается типовая четырехуровневая архитектура для всех приложений, сделанных по методологии DDD.
• Интерфейс - это уровень, который общается с пользователем и получает от него ввод.
• Операционный уровень - это уровень, который реализует взаимодействие с пользователем в рамках конкретного приложения.
• Уровень предметной области - это библиотека классов, которая может быть переиспользована и не знает о конкретных приложениях.
• Инфраструктурный уровень - это уровень, на котором находятся используемые программы и библиотеки, такие как базы данных и сети.

 Модель предметной области

• Модель предметной области должна быть отделена от всего остального, чтобы ее можно было переиспользовать.
• Классы модели должны уметь делать только то, для чего они предназначены, и ничего больше.
• Бизнес- регламенты должны выполняться на уровне модели предметной области.
• Уровень предметной области - это не просто классы, а содержательная логика работы бизнес-процесса.

 Умный юа и его недостатки

• Умный юа - это антипаттерн, который не рекомендуется использовать.
• Идея умного юа заключается в том, чтобы писать все прямо в обработчиках на форме или в контроллерах веб-приложения.
• Однако, такой подход имеет важные преимущества, такие как возможность быстро реализовать прототип приложения и быстро добавлять новые функции.
• Однако, такой подход не позволяет переиспользовать код и может привести к проблемам с идентификацией объектов.

Объекты и сущности

• Объекты и сущности в объектно-ориентированном программировании имеют разные значения и свойства.
• Объекты полностью определяют свои атрибуты, а сущности могут быть разделяемыми и иметь мутабельные свойства.
• В примере с кинотеатром, места в зале могут быть сущностями, а билеты на сеанс - объектами значений.

 Агрегаты и фабрики

• Агрегаты - это изолированные куски модели, имеющие корень и границу.
• Корень агрегата глобально идентичен и может быть использован для идентификации, а граница содержит только локально идентичные объекты.
• Агрегаты обеспечивают инварианты и правила взаимодействия с внешним миром через корень.
• Фабрики создают и объекты, и агрегаты, могут быть сложными и использовать различные паттерны проектирования.

 Хранилища и примеры

• Хранилища предоставляют доступ к данным из базы данных или других источников, не раскрывая подробностей о них.
• Хранилища могут быть типизированными и использоваться для доступа к содержимому агрегатов.
• В примере с системой грузоперевозок, хранилища используются для предоставления информации о местонахождении груза, оформления заказов на доставку и выставления счетов.

 Обсуждение модели предметной области

• В видео обсуждается модель предметной области для логистической компании, которая включает в себя сущности и значения, такие как груз, кастомер, история доставки, цель доставки, перевозки и другие.
• Модель также включает в себя ассоциации между этими сущностями, такие как отправка груза, получение груза, цель доставки и другие.

Уточнение модели

• Уточнение модели включает в себя разделение на отдельные приложения, которые будут работать с моделью, и определение конкретных задач для каждого приложения.
• Это позволяет более точно определить, как модель будет использоваться и какие технические детали будут необходимы для ее реализации.

Агрегаты и репозитории

• В модели определены агрегаты, такие как груз и история доставки, и репозитории для работы с этими агрегатами.
• Репозитории позволяют искать объекты в приложении, например, кастомеры или грузы.
• Модель также включает в себя разделение объектов между агрегатами, что позволяет использовать их в разных приложениях без необходимости их повторного создания.

Разбиение по модулям

• В системе доставки грузов, где каждый груз может состоять из нескольких компонентов, предлагается использовать репозитории для добавления новых хелли кэвенов, чтобы избежать проблем с производительностью.
• Разбиение по модулям может быть выполнено для удобства сопровождения и изоляции ключевых компонентов системы.

Паттерн спецификация

• Паттерн спецификация позволяет инкапсулировать ограничения в отдельный объект, который может быть использован для проверки и корректировки результатов.
• Паттерн может быть применен для выборки объектов из репозитории и для реализации логических операций.

 Вопросы и ответы

• Диаграмма пакетов может использоваться для разбиения системы на модули, но компонент может быть более широким понятием, чем модуль.
• Агрегация - это процесс, который может быть визуализирован с помощью пакетов.
• Агрегаты могут пересекаться, и для их визуализации можно использовать прямоугольники над диаграммой.

# 12 лекция
Примеры архитектур

 Обзор систем контроля версий

• В видео обсуждается обзор систем контроля версий, включая их историю и развитие.
• Рассматриваются три разные системы контроля версий, которые решают одну и ту же задачу, но разными способами.

 Архитектура Git

• Git - это одна из первых распределенных систем контроля версий, разработанная Линусом Торвальдсом.
• Git хранит всю информацию в локальном репозитории, который организован как скрытая папка Git, лежащая рядом с исходниками.
• Git использует рефы для реализации веток и тэгов, а также для хранения информации о текущем содержимом рабочей копии.
• Git также имеет набор скриптов, которые могут выполняться при выполнении действий с репозиторием, и конфиг, который содержит конфигурацию Git.
• В папке образа хранятся объекты, которые являются содержимым файлов, зипуются для эффективного хранения, но не более.
• Git использует хэширование для хранения информации о файлах, что позволяет быстро находить нужный файл в файловой системе.

 Организация версионного контроля

• В видео обсуждается организация версионного контроля в Git.
• Для этого используется команда "гид", которая распаковывает содержимое файла и печатает его обратно.
• Это позволяет создать мини-систему контроля версий, где каждая версия файла хранится как отдельный файл.

 Три обжита и комиты

• Для хранения древовидной структуры используются три обжита, которые хранят мета-информацию о файлах в рабочей копии.
• Каждый обжиг отвечает за свою папку, и хэши используются как указатели на эти объекты в файловой системе.

 История комитов и рефы

• Комиты используются для хранения мета-информации об изменениях, и они могут быть созданы с помощью команды "гидками три".
• Комиты могут иметь родителей, и список комитов позволяет выстроить историю изменений.
• Рефы - это не объекты, а просто имена для хэшей, которые хранятся в папке "ревз".
• Рефы могут ссылаться на комиты или на что-то другое, и они могут быть изменены вручную.

Рефлок и метки

• Рефлок - структура данных, которая запоминает все действия с веткой.
• Метки - ссылки на коммиты, которые позволяют переключаться между ветками.
• Текущая ветка хранится в хэте, который является символической ссылкой на имя файла.

 Пак-файлы и крифлок

• Пак-файлы используются для сжатия файлов и хранения их в одном большом файле.
• Крифлок - структура данных, которая отслеживает изменения в ветках.
• Позволяет восстановить ветку, если она случайно удалена.

 Восстановление веток и паролей

• Команда гит чек позволяет найти висячие объекты и восстановить их.
• Если случайно закомили пароль от контакта на гитхаб, его нужно поменять.
• Случайное закомиление четырех гигабайтного фильма с девяти диска может привести к серьезным проблемам.

 Хранение бинарных файлов

• Автор обсуждает, что многие начинающие пользователи git ошибочно хранят бинарные файлы в репозиториях, что приводит к их разрастанию до 200-500 мегабайт.
• Он рекомендует не выкладывать бинарные файлы, а использовать докер для их хранения и сборки.

Управление зависимостями

• Автор обсуждает, что хранение бинарных файлов в репозиториях может привести к проблемам с внезапным изменением версии компилятора или других зависимостей.
• Он рекомендует использовать докер для хранения и сборки бинарных файлов, чтобы избежать этих проблем.

 История и мержи

• Автор обсуждает разные школы мыслей относительно истории и мержей в git.
• Он предпочитает использовать мержи, но признает, что другие школы могут предпочитать хранить историю и делать только ребейзы.

 Проблемы с Windows

• Автор обсуждает проблемы с использованием git на Windows, включая проблемы с мета-информацией о файлах и сложности с переименованием файлов.
• Он также упоминает, что git стал самой популярной системой контроля версий в 2005-2010 годах, но его сложная система команд и отсутствие туториалов для начинающих могут затруднять обучение.

 Противоположность Git

• В качестве противоположности Git рассматривается Mercurial, который решает те же задачи, но с другим подходом.
• Mercurial разрабатывался медленнее, но с большим вниманием к деталям и архитектуре.
• Он был написан на Python и изначально планировался как расширяемая система, которую каждый пользователь может дописывать и настраивать под свои нужды.

 Структура данных и хранение информации

• Основа структуры данных Mercurial - ревок, который хранит всю информацию о хранимых данных.
• Каждый файл хранится в виде ревизий, которые хранятся в виде дельт.
• Ревизии описываются с помощью записей в ревлоге, которые также используют дельта-компрессию для эффективного хранения информации.
• Ревлоги образуют иерархическую структуру, где есть чейндж лок - общий для всего репозитория, манифест - хранит информацию о файлах и ссылку на логи, и дир стейт - информация о рабочей копии и кэш дерева файла.
• Ревоги обновляются в определенном порядке, начиная с файла лога и далее, что позволяет избежать проблем с питанием.
• Ревлогии - полноценные объекты в репозитории, которые также используют дельта-компрессию для хранения только измененных файлов.

 Ревизии и ветки в Mercurial

• В Mercurial ревизии имеют вокальный номер, который позволяет быстро найти нужную ревизию.
• Локальные ревизии имеют хэш, который используется для операций с удаленными ревизиями.
• Ветви в Mercurial реализованы через именованные ветки, которые хранятся в ревлогах.
• Последний комит в каждой ветке называется типом, и есть последний по времени комит, который считается типом последней ветки.

 Анонимные ветки и теги

• В Mercurial есть возможность создавать анонимные ветки, которые можно легко удалить или забыть.
• Для удобства использования анонимных веток есть букмарки, которые работают как git-теги.
• Теги хранятся как файлы в репозитории Mercurial.

 Расширения и плагины

• В Mercurial есть механизмы расширения, такие как возможность добавить новые команды, переопределить опции команд, переиспользовать опции в разных командах, а также возможность писать обертки для существующих команд.
• Возможность подсунуть свои репозитории позволяет использовать локальную разработку с помощью меркурийских команд над репозиторием свершины.
• Механизмы лясов позволяют переопределять названия команд с параметрами, а механизмы фуков могут быть реализованы на Python или Shell.

 Обзор меркурия и гита

• Авторы обсуждают преимущества и недостатки меркурия и гита, включая простоту использования, скорость запуска и проблемы с переименованием файлов.
• Они также упоминают, что меркурий имеет простую систему команд и конфигурируемость, что делает его удобным для использования в проектах.

 Сравнение меркурия и гита

• Авторы сравнивают меркурий и гит, отмечая, что меркурий имеет эффективную модель данных, но плохо работает с переименованием файлов.
• Они также обсуждают, что меркурий имеет простую систему команд и конфигурируемость, что делает его удобным для использования в проектах.
• В то же время, гит имеет интерактивный режим и полнофункциональный клиент, что делает его популярным среди разработчиков.

Выбор между меркурием и гитом

• Авторы обсуждают, почему меркурий и гит могут быть выбраны для разных проектов, учитывая их преимущества и недостатки.
• Они также упоминают, что меркурий и гит решают одну и ту же задачу, но меркурий может быть предпочтительнее, если он лучше подходит для конкретного проекта.

# 13 лекция
Проектирование распределенных приложений, часть первая: технические вопросы

 Распределенные приложения

• В современном мире большинство приложений являются распределенными, использующими внешние сервисы и развернутыми в облаке.
• Распределенные системы состоят из независимых компонентов, работающих в разных процессах и машинах, взаимодействующих через обмен сообщениями.
• Они предназначены для работы с общими ресурсами, большими объемами данных или вычислений.

 Заблуждения и ошибки

• Заблуждения: ожидание синхронного выполнения методов, задержка, пропускная способность, безопасность, топология сети, администрирование, бесплатность, аппаратные ресурсы.
• Важно учитывать возможности независимого отказа компонентов и среды передачи, задержки, безопасности, топологии сети, администрирования, аппаратных ресурсов и бесплатности.

 Примеры и советы

• Примеры: образовательные приложения, проблемы с безопасностью, расходы на сетевое оборудование и инфраструктуру.
• Советы: учитывать расходы на сетевое оборудование, инфраструктуру, аппаратные ресурсы, однородность сети, специфику протоколов.

 Проблемы написания распределенных систем

• Обсуждение проблем, связанных с написанием распределенных систем, включая межпроцессное взаимодействие, удаленные вызовы и очереди сообщений.
• Упоминается, что в реальных системах чаще используются протоколы прикладного уровня поверх TCP/IP, такие как REST.

 Варианты размещения кода

• Упоминаются различные варианты размещения кода, включая уровневую архитектуру, репликацию серверов, микросервисную архитектуру и отправку кода на сторону клиента.
• Обсуждаются мобильные агенты, браузерное кэширование и использование механизмов удаленного вызова.

Механизмы удаленного вызова

• Рассматривается RPC (удаленный вызов процедур) как один из самых простых способов удаленного вызова.
• RPC-системы работают по принципу "вызов-ответ", где клиентская программа формирует запрос, который отправляется клиентской заглушке, а серверная заглушка дергает процедуру, реализованную программистом.

 Удаленные вызовы и их обработка

• Удаленные вызовы могут быть успешными или неудачными, и их обработка может быть сложной.
• Отказы сети могут привести к повторным попыткам доставки сообщений.
• Важно различать временные и постоянные отказы, и учитывать семантику запросов и обработки ошибок.

 Технические аспекты реализации удаленных вызовов

• Протобаф - бинарный формат реализации, используемый для передачи данных между угловыми сервисами.
• Протобав обеспечивает компактность и обратную совместимость, позволяя серверам и клиентам работать с разными версиями сервиса.
• Грпц - классическая реализация схемы удаленного вызова, использующая протобав для передачи данных и обработки исключений.

Разработка сервисов с использованием протокола Герпеи

• Герпеи - это механизм для создания легковесных сервисов, которые не должны торчать наружу.
• Герпеи можно использовать для разработки внутренних сервисов, но для внешних сервисов лучше использовать более открытые протоколы, такие как REST.

 Синхронный и асинхронный режимы работы с Герпеи

• Герпеи поддерживает запрос-ответ и разные виды взаимодействия, включая синхронный и асинхронный режимы.
• В синхронном режиме клиент может в любое время посылать сообщения, а сервер - в любое время посылать ответы.

Пример использования Герпеи для создания сервиса

• В примере сервиса, который возвращает данные о туристическом маршруте, используется синхронный режим работы с Герпеи.
• Клиент и сервер общаются через обсерверы, которые обрабатывают запросы и ответы.

Использование Герпеи для разработки распределенных приложений

• Герпеи может использоваться для разработки распределенных приложений, но для обеспечения безопасности данных обычно используется шифрование канала передачи.

 Веб-сервисы и их использование

• Веб-сервисы предоставляют удаленные вызовы и метаинформацию, что позволяет им работать без описания.
• Веб-сервисы проектируются как набор веб-сервисов, которые взаимодействуют друг с другом.
• Веб-сервисы используют протокол HTTP для передачи данных, но не всегда поддерживают сложные механизмы взаимодействия, такие как распределенные транзакции.

 Веб-сервисы и их реализация

• Веб-сервисы могут быть реализованы на разных языках, включая Java, C#, и C++.
• Веб-сервисы используют протокол SOAP для передачи данных, но он может быть многословным и не всегда подходит для открытых сервисов.
• Веб-сервисы могут быть реализованы с использованием стандарта WSDL, который позволяет генерировать клиентские заглушки без необходимости иметь априорные знания о сервисе.

 Проблемы веб-сервисов и их использование

• Веб-сервисы изначально проектировались как связующий механизм для интернет-сервисов, но идея не прижилась из-за сложности интеграции со сторонним кодом и возможности третьей стороны диктовать свои условия.
• Веб-сервисы используются в основном внутри локальных сетей предприятий, где есть возможность контролировать безопасность и нет ограничений по трафику.
• Веб-сервисы могут быть реализованы с использованием протокола SOAP, который может быть многословным и не всегда подходит для открытых сервисов.

Технология со

• Со - это технология, которая позволяет реализовать сервисы через декоративный подход, где интерфейс размечается атрибутами и нажимается одна кнопка для получения готового изделия.
• Со обладает высокой надежностью на разных уровнях: проверка на целостность сообщения, проверка корректности вызова сервиса, работа через UDP в качестве транспортного протокола.
• Однако, со имеет впечатляющий размер сообщений и сложность описаний, а также не дружит с версионированием.

 Фреймворк для реализации со сервисов

• Фреймворк DotNet WCF - это конфигурируемый фреймворк для реализации сетевых взаимодействий, который позволяет создавать энд-пойнты, бандинги, контракты и заглушки.
• Код сервиса для работы с со сервисами состоит из описания контракта, реализации сервиса и настройки энд-пойнта.

 Клиентская сторона со сервисов

• Клиентская сторона со сервисов состоит из заглушки, которая генерируется автоматически или вручную, и конфигурационного файла, который содержит адрес энд-пойнта сервера и другие параметры.
• Обработка ошибок в со сервисах обычно осуществляется через исключения, которые могут быть плохо документированы.
• В нормальных системах стратегия обработки ошибок должна быть индивидуальной для каждого приложения.

Разумная альтернатива SOAP

• Рест (REST) - разумная альтернатива SOAP, которая сейчас более популярна.
• Рест декларирует, что данные не хранятся на сервере, а таскаются запросом.
• Это позволяет выполнять разные запросы с одного клиента и не запоминать состояние сессии.

Модель данных и запросы

• Модель данных в рест-сервисах - коллекция и элементы.
• Для выполнения операций используются стандартные методы GET, POST, PUT, DELETE.
• Пример реализации рест-сервиса - Google Drive.

 Реализация рест-сервисов

• ASP.NET - фреймворк для разработки веб-приложений.
• Ве - часть ASP.NET для разработки веб-сервисов.
• Пример веб-сервиса на ASP.NET - синтетические данные, дата-трансфер-объект.

 Передача токенов

• Разные сервисы используют разные механизмы для передачи токенов.
• Пример: один токин отвечает за выполнение запроса с телефона, другой - за авторизацию пользователя.

# 14 лекция 
Проектирование распределенных приложений, 2 часть. архитектурные вопросы

Архитектурные стили для распределенных приложений

• Видео обсуждает архитектурные стили для больших распределенных приложений, таких как биг большие вычисления и биг дата.
• Биг большие вычисления подходят для вычислительно сложных задач, которые решаются с помощью суперкомпьютеров.
• Биг дата подходит для обработки большого объема данных, где вычислений не очень много, но их нужно делать много.

 Примеры и использование

• Примеры задач, которые хорошо подходят для биг больших вычислений, включают моделирование аэродинамических характеристик поверхностей и прочность.
• Для биг дата, данные обрабатываются в реальном времени или в пакетном режиме.
• Потоковая обработка подходит для обработки данных в реальном времени, а пакетная обработка - для накопления данных и обработки их позже.

Инструменты и системы

• Для обработки данных используются системы, такие как Apache Hadoop и Apache Spark.
• Apache Hadoop хранит данные в файловых системах узлов и выполняет над ними обработку в стиле MapReduce.
• Apache Spark хранит данные в памяти и работает в разы быстрее, но сложнее в конфигурации и использовании.

 Хранение данных в биг дата системах

• Хранение данных в виде слабо структурированных файлов, которые можно обрабатывать и анализировать.
• Использование вычислительных ресурсов узлов для обработки данных.
• Разделение данных по интервалам обработки для ускорения работы системы.

 Обработка приватных данных

• Удаление приватных данных еще на устройстве пользователя для предотвращения утечки информации.
• Использование филд гейтвей для сбора и обработки данных с устройств.

 Архитектурные стили

• Событийно-ориентированный стиль с шиной для распределенных приложений.
• Модели издателей-подписчиков и авенсорсинг для обработки событий.
• Использование очередей сообщений, таких как Kafka, для обработки событий в реальном времени.

 Веб-кью-воркер-дизайн

• В этом стиле архитектуры используются веб-приложения с вычислительно сложной составляющей.
• Браузерный клиент может быть реализован как одностраничное или многостраничное приложение.
• Обработчики работают с очередью сообщений, которая играет роль буфера и балансировщика нагрузки.
• Для ускорения работы с базой данных используется система Redis в качестве кэша.
• Статический контент хранится отдельно и предоставляется клиенту через контент-деливери-сеть.

Веб-ворс-приложение

• Этот стиль хорошо интегрируется с внешними сервисами и может быть собран из готовых компонентов за выходные.
• Однако, бизнес-логика живет в обработчике, что может привести к архитектурному кошмару при росте сложности обработки.
• Фронтенд-обработчик может независимо масштабироваться, если задач много, но клиентов мало.

 Резвенная архитектура

• В этом стиле бизнес-логика декомпозируется на несколько слоев или компонентов.
• Веб-слой не имеет права общаться напрямую с базой данных или внешними сервисами.
• Вместо этого, он может общаться с бизнес-логикой через сообщения или напрямую.
• Сложность масштабирования: если одна функция используется редко, а другая часто, то масштабирование может быть сложным.
• Проблемы сопровождаемости: изменения в схеме базы данных могут потребовать координации релизов обоих компонентов.

Архитектура веб-приложений

• В веб-приложениях запросы сначала попадают в деметризованную зону, где находятся нетворк вирлайнс, обеспечивающие безопасность соединения.
• Затем запросы попадают на балансировщик нагрузки, который управляет серверами, обслуживающими веб-приложения.
• Далее запросы попадают на слой бизнес-логики, где происходит обработка данных.
• База данных в системе должна быть одна, так как она должна быть в консистентном состоянии.
• Для управления системой используется бастион система, которая является единственной точкой входа в виртуальную сеть приложения.

 Микросервисная архитектура

• Микросервисная архитектура предполагает разделение приложения на небольшие кусочки, каждый из которых отвечает за свою часть работы.
• Каждый микросервис имеет свою собственную базу данных и может предоставлять элементы пользовательского интерфейса.
• Микросервисы общаются через виртуальную сеть приложения, которая является единственной точкой входа.
• Каждый микросервис - это отдельный процесс, живущий на своей виртуальной машине или в своем докер-контейнере.
• Микросервисы могут быть написаны на разных языках и технологиях, что позволяет выбрать наиболее подходящую для конкретной задачи.
• Каждый микросервис имеет свой собственный единый язык и модель предметной области.
• Микросервисы могут быть масштабированы независимо друг от друга, что позволяет быстро реагировать на изменения в нагрузке.

 Преимущества микросервисной архитектуры

• Микросервисная архитектура позволяет обнаруживать проблемы на продакшене быстро и недорого, так как каждый релиз можно быстро откатить.
• Изоляция ошибок: если один микросервис падает, это не влияет на работу всей системы.
• Простота: сложность системы скрыта в оркестраторах, а не в коде каждого сервиса.

 Сложности микросервисной архитектуры

• Сложность управления и мониторинга из-за большого сетевого взаимодействия между сервисами.
• Микросервисное приложение обычно больше по кодовой базе, чем монолитное.
• Нагрузка на сеть: каждый запрос к другому сервису - это отдельный сетевой запрос, что может замедлить работу и привести к проблемам.
• Целостность данных: микросервисы могут иметь разные состояния и обмениваться сообщениями, что может привести к неконсистентности данных.

 Принципы проектирования REST-сервисов

• Рест-сервисы должны строиться вокруг ресурсов и коллекций ресурсов, а не напрямую показывать данные пользователям.
• Переходы по ссылкам должны быть на один уровень, чтобы избежать переусложнения интерфейса.
• Программный интерфейс сервиса должен быть моделью предметной области, а не просто набором функций.

 Семантика и форматы данных

• Рекомендуется использовать семантику, подходящую для вашего сервиса, например, HTTP.
• Коды возврата и ошибки должны быть стандартизированы и использоваться правильно.
• Фильтрация и парсинг контента могут быть использованы для экономии трафика и удобства использования.

 Версионирование и гипертекста стейт

• Версионирование может быть реализовано через несколько версий сервиса или через заголовки и версии.
• Гипертекста стейт позволяет серверу возвращать свое текущее состояние и способы перехода в следующие состояния.

 Общие хорошие практики дизайна

• Обеспечение надежности приложения через возможность самоустановления, повторов и экспоненциального отката.
• Программный интерфейс для самодиагностики и разделения на изолированные группы ресурсов.
• Буферизация запросов для борьбы с пиками нагрузки.

Минимизация рисков при отказе системы

• Промежуточное сохранение для продолжения работы с прерванного момента.
• Грейс деградейшн для продолжения обслуживания клиентов при потере части компонентов.
• Случайное убийство вычислительных узлов или сетевых соединений для тестирования отказоустойчивости.

 Тестирование отказов и управление повторами

• Тестирование отказов для выявления проблем и их устранения.
• Паттерн "скает брейкер" для управления повторами и обработки ошибок.
• Таймер для определения времени, когда сервер может быть восстановлен.

 Избыточность и надежность

• В случае, если есть высоконагруженное приложение, избыточность может быть использована для обеспечения надежности.
• Однако, избыточность может стоить больших денег, поэтому важно определить требования к надежности и их стоимость.

 Балансировка нагрузки и работа с базами данных

• Балансировка нагрузки может помочь избежать отправки запросов к сервису, который не может их обслужить.
• Работа с базами данных, такими как репликация и шардирование, может помочь спасти данные в случае отказа.

Минимизация координации и использование событийных схем

• Использование событийных схем и импотентных операций может помочь минимизировать координацию и обеспечить устойчивость к отказам.
• Шардирование может быть использовано для минимизации координации и обеспечения скорости работы.

Паттерны и подходы к распределенным системам

• Паттерны, такие как разделение запросов и команд, могут помочь обеспечить согласованность и доступность в распределенных системах.
• Теорема о выборе между согласованностью, доступностью и устойчивостью к разделению может помочь определить приоритеты в разработке распределенных систем.

 Хранение данных в распределенных системах

• В распределенных системах устойчивость к разделению является обязательным требованием, так как сеть может отказать в любой момент.
• В централизованных базах данных, напротив, устойчивость к разделению отсутствует, но обеспечивается согласованность и доступность.

Транзакционная модель и ее ограничения

• В классической транзакционной модели любая модификация базы данных выполняется с помощью транзакций, которые либо происходят целиком, либо не происходят вообще.
• Модель гарантирует атомарность, изоляцию и дюрабилити, но в распределенных системах она не всегда применима.

 Бейсик левого и софт стейт

• В распределенных системах используется модель бейсик левого, которая гарантирует, что отказ одного узла может повредить только клиентам, взаимодействующим с этим узлом.
• Модель софт стейт обеспечивает целостность системы, но не гарантирует атомарность и согласованность состояния между компонентами.


